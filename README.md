## Structure and Interpretation of Computer Programs — SICP

### <a name="Оглавление"></a>  Оглавление
 + [1. ПОСТРОЕНИЕ АБСТРАКЦИЙ С ПОМОЩЬЮ ПРОЦЕДУР](#1)
   + [1.1. Элементы программирования](#1.1)
      + [1.1.1. Выражения](#1.1.1)
      + [1.1.2. Имена и окружение](#1.1.2)
      + [1.1.3. Вычисление комбинаций](#1.1.3)
      + [1.1.4. Составные процедуры](#1.1.4)
      + [1.1.5. Подстановочная модель применения процедуры](#1.1.5)
      + [1.1.6. Условные выражения и предикаты](#1.1.6)
      + [1.1.7. Пример: вычисление квадратного корня методом Ньютона](#1.1.7)
      + [1.1.8. Процедуры как абстракции типа «черный ящик»](#1.1.8)
    - [1.2. Процедуры и порождаемые ими процессы](#1.2)
      + [1.2.1. Линейные рекурсия и итерация](#1.2.1)
      + [1.2.2. Древовидная рекурсия.](#1.2.2)
      + [1.2.3. Порядки роста](#1.2.3)
      + [1.2.4. Возведение в степень](#1.2.4)
      + [1.2.5. Нахождение наибольшего общего делителя](#1.2.5)
      + [1.2.6. Пример: проверка на простоту](#1.2.6)

---
### <a name="1"></a>	1. ПОСТРОЕНИЕ АБСТРАКЦИЙ С ПОМОЩЬЮ ПРОЦЕДУР
---
#### <a name="1.1"></a>	1.1. Элементы программирования 

Всякий язык программирования обладает тремя предназначенными для этого механизмами:
элементарные выражения, представляющие минимальные сущности, с которыми язык имеет дело;
средства комбинирования, с помощью которых из простых объектов составляются сложные;
средства абстракции, с помощью которых сложные объекты можно называть и обращаться с ними как с единым целым.  
В программировании мы имеем дело с двумя типами объектов: процедурами и данными.
Говоря неформально, данные — это «материал», который мы хотим обрабатывать, а процедуры — это описания правил обработки данных
##### [Оглавление](#--оглавление)

---
##### <a name="1.1.1"></a>	1.1.1. Выражения
Выражения, представляющие числа, могут сочетаться с выражением, представляющим элементарную процедуру (скажем, + или *), так что получается составное выражение, представляющее собой применение процедуры к этим числам. Например:

    (+ 1 4)  
    5

Выражения такого рода, образуемые путем заключения списка выражений в скобки с целью обозначить применение функции к аргументам, называются комбинациями (combinations). Самый левый элемент в списке называетсяоператором (operator), а остальные элементы — операндами (operands). Значение комбинации вычисляется путем применения процедуры, задаваемой оператором, каргументам (arguments), которые являются значениями операндов

Выражения, представляющие числа, могут сочетаться с выражением, представляющим элементарную процедуру (скажем, + или *), так что получается составное выражение, представляющее собой применение процедуры к этим числам.  
Слово define служит в нашем языке простейшим средством абстракции, поскольку оно позволяет нам использовать простые имена для обозначения результатов сложных операций
Такие исключения из вышеописанного правила вычисления называются особыми формами (special forms). Define — пока что единственный встретившийся нам пример особой формы, но очень скоро мы познакомимся и с другими. У каждой особой формы свое собственное правило вычисления
##### [Оглавление](#--оглавление)

---
##### <a name="1.1.2"></a>	1.1.2. Имена и окружение
Имя обозначает переменную (variable), чьим значением (value) является объект.  
В диалекте Лиспа Scheme мы даем вещам имена с помощью слова define. Предложение

    (define size 2)

заставляет интерпретатор связать значение 2 с именем size. После того, как имя size связано со значением 2, мы можем указывать на значение 2 с помощью имени

    size
    2
Слово define служит в нашем языке простейшим средством абстракции, поскольку оно позволяет нам использовать простые имена для обозначения результатов сложных операций 
Такие исключения из вышеописанного правила вычисления называются особыми формами (special forms). Define — пока что единственный встретившийся нам пример особой формы, но очень скоро мы познакомимся и с другими. У каждой особой формы свое собственное правило вычисления
##### [Оглавление](#--оглавление)

---
##### <a name="1.1.3"></a>	1.1.3. Вычисление комбинаций

Чтобы вычислить комбинацию, требуется:  
– Вычислить все подвыражения комбинации.  
– Применить процедуру, которая является значением самого левого подвыражения (оператора) к аргументам — значениям остальных подвыражений (операндов). 
Правило вычисления рекурсивно (recursive) по своей природе  
Форма правила вычисления «распространить значения наверх» является примером общего типа процессов,
известного как накопление по дереву (tree accumulation).  
В таком диалоговом языке, как Лисп, не имеет смысла говорить о значении выражения, скажем, 

    (+ x 1)

не указывая никакой информации об окружении, которое дало бы значение символу x (и даже символу +)
##### [Оглавление](#--оглавление)

---
##### <a name="1.1.4"></a>	1.1.4. Составные процедуры

Определения процедур (procedure definitions) — значительно более мощном методе абстракции, с помощью которого составной операции можно дать имя и затем ссылаться на нее как на единое целое.

"Для начала рассмотрим, как выразить понятие «возведения в квадрат». Можно сказать так: «Чтобы возвести что-нибудь в квадрат, нужно умножить его само на себя».
Вот как это выражается в нашем языке:

    (define (square x) (* x x))

Здесь мы имеем составную процедуру (compound procedure), которой мы дали имя square. Эта процедура представляет операцию умножения чего-либо само на себя. Та вещь, которую нужно подвергнуть умножению, получает здесь имя x, которое играет ту же роль, что в естественных языках играет местоимение. Вычисление этого определения создает составную процедуру и связывает ее с именем square."
Общая форма определения процедуры такова:  

    (define ((имя) (формальные-параметры)) (тело))

(Имя) — это тот символ, с которым нужно связать в окружении определение процедуры   
(Формальные-параметры) — это имена, которые в теле процедуры используются для отсылки к соответствующим аргументам процедуры.   
(Тело) — это выражение, которое вычислит результат применения процедуры, когда формальные параметры будут заменены аргументами, к которым процедура будет применяться   
(Имя) и (формальные-параметры) заключены в скобки, как это было бы при вызове определяемой процедуры.   
##### [Оглавление](#--оглавление)

---

##### <a name="1.1.5"></a>	1.1.5. Подстановочная модель применения процедуры

Подстановочная модель
Чтобы применить составную процедуру к аргументам, требуется вычислить тело процедуры, заменив каждый формальный параметр соответствующим аргументом.  
Другая модель вычисления не вычисляет аргументы, пока не понадобится их значение. Вместо этого она подставляет на место параметров выражения-операнды, пока не получит выражение, в котором присутствуют только элементарные операторы, и лишь затем вычисляет его    
Метод «полная подстановка, затем редукция» известен под названием нормальный порядок вычислений (normal-order evaluation), в противоположность методу «вычисление аргументов, затем применение процедуры», которое называется аппликативным порядком вычислений (applicative-order evaluation).

##### [Оглавление](#--оглавление)

---

##### <a name="1.1.6"></a>	1.1.6. Условные выражения и предикаты

Лиспе существует особая форма для обозначения такого разбора случаев.Она называется cond (от английского слова conditional, «условный») и используется так: 

    (define (abs x)
    (cond ((> x 0) x)
    ((= x 0) 0)
    ((< x 0) (- x))))

Общая форма условного выражения такова: 

    (cond 
    ((p1) (e1))
    ((p2) (e2))
    ...
    ((pn) (en))
    )
Она состоит из символа cond, за которым следуют заключенные в скобки пары выражений ((p) (e)), называемых ветвями (clauses). В каждой из этих пар первое выражение — предикат (predicate), то есть выражение, значение которого интерпретируется как истина или ложь.   
Условные выражения вычисляются так: сначала вычисляется предикат (p1). Если его значением является ложь, вычисляется (p2). Если значение (p2) также ложь, вычисляется (p3). Этот процесс продолжается до тех пор, пока не найдется предикат, значением которого будет истина, и в этом случае интерпретатор возвращает значение соответствующего выражения-следствия (consequent expression) в качестве значения всего условного выражения. Если ни один из (p) ни окажется истинным, значение условного выражения не определено.   
Словом предикат называют процедуры, которые возвращают истину или ложь, а также выражения, которые имеют значением истину или ложь. Процедура вычисления модуля использует элементарные предикаты <,= и >.    
Они принимают в качестве аргументов по два числа и, проверив, меньше ли первое из них второго, равно ему или больше, возвращают в зависимости от этого истину или ложь.

    (define (abs x)
    (cond ((< x 0) (- x))
    (else x)))

что на русском языке можно было бы выразить следующим образом: «если x меньше нуля, вернуть −x; иначе вернуть x». 
Else — специальный символ, который в заключительной ветви cond можно использовать на месте (p). Это заставляет cond вернуть в качестве значения значение соответствующего (e) в случае, если все предыдущие ветви были пропущены. На самом деле, здесь на месте (p) можно было бы использовать любое выражение, которое всегда имеет значение истина.   

Вот еще один способ написать процедуру вычисления модуля:  
    (define (abs x)   
    (if (< x 0)   
    (- x)   
    x))   
    
Здесь употребляется особая форма if, ограниченный вид условного выражения. Его можно использовать при разборе случаев, когда есть ровно два возможных исхода. Общая форма выражения if такова:  
    (if (предикат) (следствие) (альтернатива))    
    
Чтобы вычислить выражение if, интерпретатор сначала вычисляет его (предикат). Если (предикат)  дает истинное значение, интерпретатор вычисляет (следствие) и возвращает его значение. В противном случае он вычисляет (альтернативу) и возвращает ее значение.

##### [Оглавление](#--оглавление)

---

##### <a name="1.1.7"></a>	1.1.7. Пример: вычисление квадратного корня методом Ньютона

мы записываем начальное приближение как 1.0, а не как 1. 
Во многих реализациях Лиспа здесь не будет никакой разницы. Однако интерпретатор MIT Scheme отличает точные целые числа от десятичных значений, и при делении двух целых получается не десятичная дробь, а рациональное число. 

Например, поделив 10/6, получим 5/3, а поделив 10.0/6.0, получим 1.6666666666666667. (Мы увидим, какcреализовать арифметические операции над рациональными числами, в разделе 2.1.1.) Если в нашей программеcквадратного корня мы начнем с начального приближения 1, а x будет точным целым числом, все последующие значения, получаемые при вычислении квадратного корня, будут не десятичными дробями, а рациональными числами. Поскольку при смешанных операциях над десятичными дробями и рациональными числами всегда получаются десятичные дроби, то начав со значения 1.0, все прочие мы получим в виде десятичных дробей.

##### [Оглавление](#--оглавление)

---
