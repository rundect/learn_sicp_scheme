## Structure and Interpretation of Computer Programs — SICP

### <a name="Оглавление"></a>  Оглавление
 + [1. ПОСТРОЕНИЕ АБСТРАКЦИЙ С ПОМОЩЬЮ ПРОЦЕДУР](#1)
   + [1.1. Элементы программирования](#1.1)
      + [1.1.1. Выражения](#1.1.1)
      + [1.1.2. Имена и окружение](#1.1.2)
      + [1.1.3. Вычисление комбинаций](#1.1.3)
      + [1.1.4. Составные процедуры](#1.1.4)
      + [1.1.5. Подстановочная модель применения процедуры](#1.1.5)
      + [1.1.6. Условные выражения и предикаты](#1.1.6)
      + [1.1.7. Пример: вычисление квадратного корня методом Ньютона](#1.1.7)
      + [1.1.8. Процедуры как абстракции типа «черный ящик»](#1.1.8)
    - [1.2. Процедуры и порождаемые ими процессы](#1.2)
      + [1.2.1. Линейные рекурсия и итерация](#1.2.1)
      + [1.2.2. Древовидная рекурсия.](#1.2.2)
      + [1.2.3. Порядки роста](#1.2.3)
      + [1.2.4. Возведение в степень](#1.2.4)
      + [1.2.5. Нахождение наибольшего общего делителя](#1.2.5)
      + [1.2.6. Пример: проверка на простоту](#1.2.6)

---
### <a name="1"></a>	1. ПОСТРОЕНИЕ АБСТРАКЦИЙ С ПОМОЩЬЮ ПРОЦЕДУР
---
#### <a name="1.1"></a>	1.1. Элементы программирования 

Всякий язык программирования обладает тремя предназначенными для этого механизмами:
элементарные выражения, представляющие минимальные сущности, с которыми язык имеет дело;
средства комбинирования, с помощью которых из простых объектов составляются сложные;
средства абстракции, с помощью которых сложные объекты можно называть и обращаться с ними как с единым целым.  
В программировании мы имеем дело с двумя типами объектов: процедурами и данными.
Говоря неформально, данные — это «материал», который мы хотим обрабатывать, а процедуры — это описания правил обработки данных
##### [Оглавление](#--оглавление)

---
##### <a name="1.1.1"></a>	1.1.1. Выражения
Выражения, представляющие числа, могут сочетаться с выражением, представляющим элементарную процедуру (скажем, + или *), так что получается составное выражение, представляющее собой применение процедуры к этим числам. Например:

    (+ 1 4)  
    5

Выражения такого рода, образуемые путем заключения списка выражений в скобки с целью обозначить применение функции к аргументам, называются комбинациями (combinations). Самый левый элемент в списке называетсяоператором (operator), а остальные элементы — операндами (operands). Значение комбинации вычисляется путем применения процедуры, задаваемой оператором, каргументам (arguments), которые являются значениями операндов

Выражения, представляющие числа, могут сочетаться с выражением, представляющим элементарную процедуру (скажем, + или *), так что получается составное выражение, представляющее собой применение процедуры к этим числам.  
Слово define служит в нашем языке простейшим средством абстракции, поскольку оно позволяет нам использовать простые имена для обозначения результатов сложных операций
Такие исключения из вышеописанного правила вычисления называются особыми формами (special forms). Define — пока что единственный встретившийся нам пример особой формы, но очень скоро мы познакомимся и с другими. У каждой особой формы свое собственное правило вычисления
##### [Оглавление](#--оглавление)

---
##### <a name="1.1.2"></a>	1.1.2. Имена и окружение
Имя обозначает переменную (variable), чьим значением (value) является объект.  
В диалекте Лиспа Scheme мы даем вещам имена с помощью слова define. Предложение

    (define size 2)

заставляет интерпретатор связать значение 2 с именем size. После того, как имя size связано со значением 2, мы можем указывать на значение 2 с помощью имени

    size
    2
Слово define служит в нашем языке простейшим средством абстракции, поскольку оно позволяет нам использовать простые имена для обозначения результатов сложных операций 
Такие исключения из вышеописанного правила вычисления называются особыми формами (special forms). Define — пока что единственный встретившийся нам пример особой формы, но очень скоро мы познакомимся и с другими. У каждой особой формы свое собственное правило вычисления
##### [Оглавление](#--оглавление)

---
##### <a name="1.1.3"></a>	1.1.3. Вычисление комбинаций

Чтобы вычислить комбинацию, требуется:  
– Вычислить все подвыражения комбинации.  
– Применить процедуру, которая является значением самого левого подвыражения (оператора) к аргументам — значениям остальных подвыражений (операндов). 
Правило вычисления рекурсивно (recursive) по своей природе  
Форма правила вычисления «распространить значения наверх» является примером общего типа процессов,
известного как накопление по дереву (tree accumulation).  
В таком диалоговом языке, как Лисп, не имеет смысла говорить о значении выражения, скажем, 

    (+ x 1)

не указывая никакой информации об окружении, которое дало бы значение символу x (и даже символу +)
##### [Оглавление](#--оглавление)

---
##### <a name="1.1.4"></a>	1.1.4. Составные процедуры

Определения процедур (procedure definitions) — значительно более мощном методе абстракции, с помощью которого составной операции можно дать имя и затем ссылаться на нее как на единое целое.

"Для начала рассмотрим, как выразить понятие «возведения в квадрат». Можно сказать так: «Чтобы возвести что-нибудь в квадрат, нужно умножить его само на себя».
Вот как это выражается в нашем языке:

    (define (square x) (* x x))

Здесь мы имеем составную процедуру (compound procedure), которой мы дали имя square. Эта процедура представляет операцию умножения чего-либо само на себя. Та вещь, которую нужно подвергнуть умножению, получает здесь имя x, которое играет ту же роль, что в естественных языках играет местоимение. Вычисление этого определения создает составную процедуру и связывает ее с именем square."
Общая форма определения процедуры такова:  

    (define ((имя) (формальные-параметры)) (тело))

(Имя) — это тот символ, с которым нужно связать в окружении определение процедуры   
(Формальные-параметры) — это имена, которые в теле процедуры используются для отсылки к соответствующим аргументам процедуры.   
(Тело) — это выражение, которое вычислит результат применения процедуры, когда формальные параметры будут заменены аргументами, к которым процедура будет применяться   
(Имя) и (формальные-параметры) заключены в скобки, как это было бы при вызове определяемой процедуры.   
##### [Оглавление](#--оглавление)

---

##### <a name="1.1.5"></a>	1.1.5. Подстановочная модель применения процедуры

Вычисляя комбинацию, оператор которой называет составную процедуру, интерпретатор осуществляет, вообще говоря, тот же процесс, что и для комбинаций, операторы которых называют элементарные процедуры — процесс, описанный в разделе 1.1.3. А именно, интерпретатор вычисляет элементы комбинации и применяет процедуру (значение оператора комбинации) к аргументам (значениям операндов комбинации).  
Мы можем предположить, что механизм применения элементарных процедур к аргументам встроен в интерпретатор. Для составных процедур процесс протекает так:  
• Чтобы применить составную процедуру к аргументам, требуется вычислить тело процедуры, заменив каждый формальный параметр соответствующим аргументом.
Чтобы проиллюстрировать этот процесс, вычислим комбинацию  

    (f 5)
    
где f — процедура, определенная в разделе 1.1.4. Начинаем мы с того, что восстанавливаем тело f:

    (sum-of-squares (+ a 1) (* a 2))  
    
Затем мы заменяем формальный параметр a на аргумент 5:

    (sum-of-squares (+ 5 1) (* 5 2))  
    
Таким образом, задача сводится к вычислению комбинации с двумя операндами и оператором sum-of-squares. Вычисление этой комбинации включает три подзадачи. Нам нужно вычислить оператор, чтобы получить процедуру, которую требуется применить, а также операнды, чтобы получить аргументы. При этом (+ 5 1) дает 6, а (* 5 2) дает 10, так что нам требуется применить процедуру sum-of-squares к 6 и 10. Эти значения подставляются на место формальных параметров x и y в теле sum-of-squares,приводя выражение к  

    (+ (square 6) (square 10))  
    
Когда мы используем определение square, это приводится к

    (+ (* 6 6) (* 10 10))  
    
что при умножении сводится к

	(+ 36 100)  
	
и, наконец, к  

	136



Аппликативный и нормальный порядки вычисления
В соответствии с описанием из раздела 1.1.3, интерпретатор сначала вычисляет оператор и операнды, а затем применяет получившуюся процедуру к получившимся аргументам. Но это не единственный способ осуществлять вычисления.  
Другая модель вычисления не вычисляет аргументы, пока не понадобится их значение. Вместо этого она подставляет на место параметров выражения-операнды, пока не получит выражение, в котором присутствуют только элементарные операторы, и лишь затем вычисляет его.  
Альтернативный метод «полная подстановка, затем редукция» известен под названием нормальный порядок вычислений (normal-order evaluation), в противоположность методу «вычисление аргументов, затем применение процедуры», которое называется аппликативным порядком вычислений (applicative-order evaluation). Можно показать, что для процедур, которые правильно моделируются с помощью подстановки (включая все процедуры из первых двух глав этой книги) и возвращают законные значения, нормальный и аппликативный порядки вычисления дают одно и то же значение. (См. упражнение 1.5, где приводится пример «незаконного» выражения, для которого нормальный и аппликативный порядки вычисления дают разные результаты.)  
В Лиспе используется аппликативный порядок вычислений, отчасти из-за дополнительной эффективности, которую дает возможность не вычислять многократно выражения вроде приведенных выше (+ 5 1) и (* 5 2), а отчасти, что важнее, потому что с нормальным порядком вычислений становится очень сложно обращаться, как только мы покидаем область процедур, которые можно смоделировать с помощью подстановки.

##### [Оглавление](#--оглавление)

---

##### <a name="1.1.6"></a>	1.1.6. Условные выражения и предикаты

Лиспе существует особая форма для обозначения такого разбора случаев.Она называется cond (от английского слова conditional, «условный») и используется так: 

    (define (abs x)
    (cond ((> x 0) x)
    ((= x 0) 0)
    ((< x 0) (- x))))

Общая форма условного выражения такова: 

    (cond 
    ((p1) (e1))
    ((p2) (e2))
    ...
    ((pn) (en))
    )
Она состоит из символа cond, за которым следуют заключенные в скобки пары выражений ((p) (e)), называемых ветвями (clauses). В каждой из этих пар первое выражение — предикат (predicate), то есть выражение, значение которого интерпретируется как истина или ложь.   
Условные выражения вычисляются так: сначала вычисляется предикат (p1). Если его значением является ложь, вычисляется (p2). Если значение (p2) также ложь, вычисляется (p3). Этот процесс продолжается до тех пор, пока не найдется предикат, значением которого будет истина, и в этом случае интерпретатор возвращает значение соответствующего выражения-следствия (consequent expression) в качестве значения всего условного выражения. Если ни один из (p) ни окажется истинным, значение условного выражения не определено.   
Словом предикат называют процедуры, которые возвращают истину или ложь, а также выражения, которые имеют значением истину или ложь. Процедура вычисления модуля использует элементарные предикаты <,= и >.    
Они принимают в качестве аргументов по два числа и, проверив, меньше ли первое из них второго, равно ему или больше, возвращают в зависимости от этого истину или ложь.

    (define (abs x)
    (cond ((< x 0) (- x))
    (else x)))

что на русском языке можно было бы выразить следующим образом: «если x меньше нуля, вернуть −x; иначе вернуть x». 
Else — специальный символ, который в заключительной ветви cond можно использовать на месте (p). Это заставляет cond вернуть в качестве значения значение соответствующего (e) в случае, если все предыдущие ветви были пропущены. На самом деле, здесь на месте (p) можно было бы использовать любое выражение, которое всегда имеет значение истина.   

Вот еще один способ написать процедуру вычисления модуля:

	(define (abs x)
	(if (< x 0)   
	(- x)   
	x))   
    
Здесь употребляется особая форма if, ограниченный вид условного выражения. Его можно использовать при разборе случаев, когда есть ровно два возможных исхода. Общая форма выражения if такова:  
    (if (предикат) (следствие) (альтернатива))    
    
Чтобы вычислить выражение if, интерпретатор сначала вычисляет его (предикат). Если (предикат)  дает истинное значение, интерпретатор вычисляет (следствие) и возвращает его значение. В противном случае он вычисляет (альтернативу) и возвращает ее значение.

##### [Оглавление](#--оглавление)

---
##### <a name="1.1.7"></a>	1.1.7. Пример: вычисление квадратного корня методом Ньютона

мы записываем начальное приближение как 1.0, а не как 1. 
Во многих реализациях Лиспа здесь не будет никакой разницы. Однако интерпретатор MIT Scheme отличает точные целые числа от десятичных значений, и при делении двух целых получается не десятичная дробь, а рациональное число. 

Например, поделив 10/6, получим 5/3, а поделив 10.0/6.0, получим 1.6666666666666667. (Мы увидим, какcреализовать арифметические операции над рациональными числами, в разделе 2.1.1.) Если в нашей программеcквадратного корня мы начнем с начального приближения 1, а x будет точным целым числом, все последующие значения, получаемые при вычислении квадратного корня, будут не десятичными дробями, а рациональными числами. Поскольку при смешанных операциях над десятичными дробями и рациональными числами всегда получаются десятичные дроби, то начав со значения 1.0, все прочие мы получим в виде десятичных дробей.

##### [Оглавление](#--оглавление)

---
##### <a name="1.1.8"></a>	1.1.8. Процедуры как абстракции типа «черный ящик»

Sqrt — наш первый пример процесса, определенного множеством зависимых друг от друга процедур. Заметим, что определение sqrt-iter рекурсивно (recursive); это означает, что процедура определяется в терминах самой себя. Идея, что можно определить процедуру саму через себя  

![изображение](https://user-images.githubusercontent.com/93350655/181362812-8d0a80fa-faf5-4189-8937-de563e724d66.png)

Пока мы рассматриваем процедуру good-enough?, square — не совсем процедура, но скорее абстракция процедуры, так называемая процедурная абстракция (procedural abstraction

###### Локальные имена
Одна из деталей реализации, которая не должна заботить пользователя процедуры — это то, какие человек, писавший процедуру, выбрал имена для формальных параметров процедуры. Таким образом, следующие две процедуры должны быть неотличимы:

	(define (square x) (* x x))
	(define (square y) (* y y))

Этот принцип — что значение процедуры не должно зависеть от имен параметров, которые выбрал ее автор, — может сначала показаться очевидным, однако он имеет глубокие следствия. Простейшее из этих следствий состоит в том, что имена параметров должны быть локальными в теле процедуры.

У формального параметра особая роль в определении процедуры: не имеет значения, какое у этого параметра имя. Такое имя называется связанной переменной (bound
variable), и мы будем говорить, что определение процедуры связывает (binds) свои формальные параметры. Значение процедуры не изменяется, если во всем ее определении параметры последовательным образом переименованы. Если переменная не связана, мы говорим, что она свободна (free). Множество выражений, для которых связывание определяет имя, называется областью действия (scope) этого имени. В определении процедуры связанные переменные, объявленные как формальные параметры процедуры, имеют своей областью действия тело процедуры.

###### Внутренние определения и блочная структура
Такое вложение определений, называемое блочной структурой (block structure), дает правильное решение для простейшей задачи упаковки имен. Но здесь таится еще одна идея. Помимо того, что мы можем вложить определения вспомогательных процедур внутрь главной, мы можем их упростить. Поскольку переменная x связана в определении sqrt, процедуры good-enough?, improve и sqrt-iter, которые определены внутри sqrt, находятся в области действия x. Таким образом, нет нужды явно передавать x в каждую из этих процедур. Вместо этого мы можем сделать x свободной переменной во внутренних определениях, как это показано ниже. Тогда x получит свое значение от аргумента, с которым вызвана объемлющая их процедура sqrt. Такой порядок называется лексической сферой действия (lexical scoping) переменных


##### [Оглавление](#--оглавление)

---
#### <a name="1.2"></a>	1.2. Процедуры и порождаемые ими процессы
